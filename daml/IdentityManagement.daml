module IdentityManagement where

--import DA.Optional
--import DA.Exception
import DA.List

template EncryptionKey 
  with
    id : Text
    owner : Party
    groupId: Text
    wrappedKey: Text

  where
    signatory owner
  
    key (owner, groupId, id) : (Party, Text, Text)
    maintainer key._1

template SharedKey 
  with
    id : Text
    groupId: Text
    owner : Party
    recipient : Party
    wrappedKey: Text

  where
    signatory owner
    observer recipient
  
    key (owner, recipient, groupId, id) : (Party, Party, Text, Text)
    maintainer key._1

data Encryption
  = EncNone
    -- ^ No encryption, the file is in plain text.
  | EncAES256 with groupId: Text, keyId: Text, iv: Text
    -- ^ 256-bit AES encryption, CBC mode, PKCS5 padding
  deriving (Eq, Show)

data PrivateData
  = OnLedger with encryption: Encryption, dataValue: Text
  | OffLedger with encryption: Encryption, dataLocation: Text
    deriving (Eq, Show)

isEncNone : Encryption -> Bool
isEncNone EncNone = True
isEncNone _ = False

template DataSubject with
    id: Text
    owner: Party
    subprocessors: [Party]
    publicData1: Text
    publicData2: Text
    privateData: Optional PrivateData
  where
    signatory owner
    observer subprocessors

data PublicKey = PublicKey with
    publicKey : Text
    fingerprint : Text
      deriving (Eq,Show)

template IdentityGroup with
    owner : Party
    id: Text
    members : [Party]
  where
    signatory owner
    observer members

    key (owner, id) : (Party, Text)
    maintainer key._1

    choice InviteNewMember : ContractId IdentityGroup with
      invitee : Party

        controller owner

        do
          create this with 
            members = dedup (invitee :: members)

    choice RevokeMember : ContractId IdentityGroup with
      member : Party

        controller members
 
        do
          -- assert (owner /= member)
          create this with
            members = filter (/=member) members

    nonconsuming choice RegisterPublicKey : ContractId RegisteredIdentity with
      member: Party
      publicKey: PublicKey

        controller member
        
        do
          -- need check that they haven't registered a key previously
          assert (member `elem` (members) )
          assertMsg "PublicKey is invalid" (publicKey.publicKey /= "" && publicKey.fingerprint /= "")

          create RegisteredIdentity with 
            groupId = id
            owner
            identity = member
            publicKey

    nonconsuming choice FetchMemberKey : (ContractId RegisteredIdentity, RegisteredIdentity) with
      member: Party
      actor: Party

        controller actor
      
        do
          assert (actor `elem` (owner :: members) )
          fetchByKey @RegisteredIdentity (owner, member, id)
          
template RegisteredIdentity with
    owner : Party
    groupId : Text
    identity : Party
    publicKey : PublicKey
  where
    signatory owner
    observer identity

    key (owner, identity, groupId) : (Party, Party, Text)
    maintainer key._1

    ensure (publicKey.publicKey /= "" && publicKey.fingerprint /= "")


